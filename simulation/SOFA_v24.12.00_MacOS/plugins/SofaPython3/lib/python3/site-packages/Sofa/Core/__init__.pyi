"""

        Contains the general object hierarchy and data structures

        A SOFA simulation is referred as a "scene". A scene contains several object. Each object is implemented as the
        aggregation of components. Groups of component are grouped and organized logically using a specific container called
        Node. Nodes are hierarchically organized in a scene graph.
        For more, see the `SOFA lexicography <https://www.sofa-framework.org/community/doc/using-sofa/lexicography/>`_.

        Commonly used classes:

        .. autosummary::
                :nosignatures:

                Node
                Object
                Controller
                ForceFieldVec3d
                Data

        Example:
            .. code-block:: python

                import Sofa.Core

                # Create a new node
                n = Sofa.Core.Node("MyNode")

                # Create a new node
                n = Sofa.Core.Node("MyNode"")
                # Add a child node name 'Node2'
                n.addChild("Node2")

                # Add a mechanical component to MyNode
                n.addObject("MechanicalObject", name="dofs")

                Sofa.Simulation.init(root)
                Sofa.Simulation.print(root)

       
"""
import Sofa.Helper
from __future__ import annotations
import numpy
import pybind11_stubgen.typing_ext
import scipy.sparse
import typing
from . import TaskScheduler
__all__ = ['Base', 'BaseClass', 'BaseContext', 'BaseMass', 'BaseMechanicalState', 'BaseMeshTopology', 'BaseNode', 'BasePrefab', 'Camera', 'ClassEntry', 'ContactListener', 'Context', 'Controller', 'Data', 'DataContainer', 'DataContainerContextManager', 'DataDict', 'DataDictIterator', 'DataEngine', 'DataLink', 'DataString', 'DataVectorString', 'ForceFieldRigid2d', 'ForceFieldRigid3d', 'ForceFieldVec1d', 'ForceFieldVec2d', 'ForceFieldVec3d', 'ForceFieldVec6d', 'Link', 'LinkPath', 'MassRigid2d', 'MassRigid3d', 'MassVec1d', 'MassVec2d', 'MassVec3d', 'MassVec6d', 'Node', 'NodeIterator', 'Object', 'ObjectFactory', 'PointSetTopologyModifier', 'PrefabLink', 'RawPrefab', 'TaskScheduler', 'Topology']
class Base:
    """
    
            Base class of the scene graph hierarchy
    
            All objects are in-heriting from this one.
            
    """
    def __getattr__(self, arg0: str) -> typing.Any:
        ...
    def __setattr__(self, arg0: str, arg1: typing.Any) -> None:
        ...
    @typing.overload
    def addData(self, name: str, value: typing.Any = None, default: typing.Any = None, help: str = '', group: str = '', type: str = '') -> Data:
        """
                Create a data field, then adds it to the base
        
                Note that this method should only be called if the field was not initialized with the initData method
        
                :param self: the base itself
                :param name: the name of the data to be added
                :param value: the value from which the data can be created
                :param help: help message that describes the data to be created
                :param group: the group the data belongs to
                :param type: the type of the data
                :type self: object
                :type name: string
                :type value: object
                :type help: string
                :type group: string
                :type type: string
        """
    @typing.overload
    def addData(self, arg0: typing.Any) -> Data:
        """
                Add a data field
        
                :param self: the base itself
                :param d: the data to be added
                :type self: Base*
                :type d: object
        
                This method should only be called if the field was not initialized with the initData method
        """
    def addLink(self, name: str, value: typing.Any = None, help: str = '') -> Link:
        """
                Create a Link to a SOFA component and adds it to the base
        
                :param self: the base itself
                :param name: the name of the link to be added
                :param value: the value from which the data can be created (either a pathname or a SofaBase)
                :param help: help message that describes the link to be created
                :type self: object
                :type name: string
                :type value: object
                :type help: string
        
                This method should only be called if the field was not initialized with the initLink method
        """
    def clearLoggedMessages(self) -> typing.Any:
        """
                Remove all logged messages in the object's logs
        """
    def countLoggedMessages(self) -> typing.Any:
        """
                Returns the number of messages in the object's logs
        """
    def findData(self, arg0: str) -> Data:
        """
                Find a data field given its name
        
                If more than one field is found (due to aliases), only the first is returned.
        
                :param name
                :type name: string
                :return: the data field or None
        """
    def findLink(self, arg0: str) -> Link:
        """
                Find a link given its name
        
                Return NULL if not found.
                If more than one link is found (due to aliases), only the first is returned.
        
                :param name: the name of the link
                :type name: string
                :return: the link
        """
    def getClass(self) -> BaseClass:
        """
                Return the class of the object
        """
    def getClassName(self) -> str:
        """
                Get the name of the class of the Base.
        """
    def getData(self, arg0: str) -> typing.Any:
        """
                Get the data field given its name
        
                :param self:
                :param s:
                :type self: Base&
                :type s: string
                :return: the first data found of this name
        """
    def getDataFields(self) -> list:
        """
                Accessor to the vector containing all the fields of this object
                :return: A vector containing the data fields
        """
    def getDefinitionSourceFileName(self) -> str:
        """
        Returns the name of the file that contains the object definition.
        """
    def getDefinitionSourceFilePos(self) -> int:
        """
        Returns the line number where the object is defined.
        """
    def getInstanciationFileName(self) -> str:
        """
        Returns the line number where the object is instanciatiated.
        """
    def getInstanciationSourceFilePos(self) -> int:
        """
        Returns the line number where the object is instanciatiated.
        """
    def getLinkPath(self) -> str:
        """
                Returns the path name as a parsable string
        
                .. code-block:: python
        
                    # prints @"/child1/object" if getPathName() is "/child1/object"
                    print(object.linkPath)
        """
    def getLinks(self) -> list:
        """
                Accessor to the vector containing all the links of this object
        
                :return: A vector containing the links
        """
    def getLoggedMessagesAsString(self) -> typing.Any:
        """
                Returns a single string with all the messages logged in the internal buffer of a sofa object.
                Return empty string if there is no messages.
        """
    def getName(self) -> str:
        """
                Return the name of the entity
        
                :rtype: string
        """
    def getPathName(self) -> str:
        """
                Returns the path name as a string
        
                .. code-block:: python
        
                    a = Sofa.Core.Node("root")
                    b = a.addObject("Camera", name="camera")
                    b.getPathName() # should returns "/root/camera"
        """
    def getTemplateName(self) -> str:
        """
                Get the name of the template of the Base.
        """
    def setDataValues(self, **kwargs) -> typing.Any:
        """
                Set values for a the given data field, multiple pairs of args are allowed.
        """
    def setDefinitionSourceFileName(self, arg0: str) -> None:
        """
        set the name of the file that contains the object definition.
        """
    def setDefinitionSourceFilePos(self, arg0: int) -> None:
        """
        Set the line number where the object is defined.
        """
    def setInstanciationSourceFileName(self, arg0: str) -> None:
        """
        Set the line number where the object is instanciatiated.
        """
    def setInstanciationSourceFilePos(self, arg0: int) -> None:
        """
        Set the line number where the object is instanciatiated.
        """
    def setName(self, arg0: str) -> None:
        """
                Set the name of this object
        
                :param n
                :type n: string
        """
class BaseClass:
    """
    Class hierarchy reflection base class
    This class provides information on the class and parent classes of components.
    It is created by using the SOFA_CLASS macro on each new class declaration.
    All classes deriving from Base should use the SOFA_CLASS macro within their declaration.
    """
class BaseContext(Base):
    """
    Base class for Context classes, storing shared variables and parameters
    """
    class SearchDirection:
        """
        Members:
        
          SearchUp
        
          Local
        
          SearchDown
        
          SearchRoot
        
          SearchParents
        """
        Local: typing.ClassVar[BaseContext.SearchDirection]  # value = <SearchDirection.Local: 0>
        SearchDown: typing.ClassVar[BaseContext.SearchDirection]  # value = <SearchDirection.SearchDown: 1>
        SearchParents: typing.ClassVar[BaseContext.SearchDirection]  # value = <SearchDirection.SearchParents: 3>
        SearchRoot: typing.ClassVar[BaseContext.SearchDirection]  # value = <SearchDirection.SearchRoot: 2>
        SearchUp: typing.ClassVar[BaseContext.SearchDirection]  # value = <SearchDirection.SearchUp: -1>
        __members__: typing.ClassVar[dict[str, BaseContext.SearchDirection]]  # value = {'SearchUp': <SearchDirection.SearchUp: -1>, 'Local': <SearchDirection.Local: 0>, 'SearchDown': <SearchDirection.SearchDown: 1>, 'SearchRoot': <SearchDirection.SearchRoot: 2>, 'SearchParents': <SearchDirection.SearchParents: 3>}
        def __eq__(self, other: typing.Any) -> bool:
            ...
        def __getstate__(self) -> int:
            ...
        def __hash__(self) -> int:
            ...
        def __index__(self) -> int:
            ...
        def __init__(self, value: int) -> None:
            ...
        def __int__(self) -> int:
            ...
        def __ne__(self, other: typing.Any) -> bool:
            ...
        def __repr__(self) -> str:
            ...
        def __setstate__(self, state: int) -> None:
            ...
        def __str__(self) -> str:
            ...
        @property
        def name(self) -> str:
            ...
        @property
        def value(self) -> int:
            ...
    Local: typing.ClassVar[BaseContext.SearchDirection]  # value = <SearchDirection.Local: 0>
    SearchDown: typing.ClassVar[BaseContext.SearchDirection]  # value = <SearchDirection.SearchDown: 1>
    SearchParents: typing.ClassVar[BaseContext.SearchDirection]  # value = <SearchDirection.SearchParents: 3>
    SearchRoot: typing.ClassVar[BaseContext.SearchDirection]  # value = <SearchDirection.SearchRoot: 2>
    SearchUp: typing.ClassVar[BaseContext.SearchDirection]  # value = <SearchDirection.SearchUp: -1>
    @staticmethod
    def setGravity(*args, **kwargs) -> None:
        """
        Gravity in local coordinates
        """
    def __str__(self) -> str:
        """
        Get a string representation of the context.
        """
    def canChangeSleepingState(self) -> bool:
        """
        Whether the context can change its sleeping state or not
        """
    def getAnimate(self) -> bool:
        """
        Animation flag
        """
    def getDt(self) -> float:
        """
        Simulation timestep
        """
    def getGravity(self) -> ...:
        """
        Gravity in local coordinates
        """
    def getMass(self) -> BaseMass:
        """
        Mass
        """
    def getMechanicalState(self) -> BaseMechanicalState:
        """
        Mechanical Degrees-of-Freedom
        """
    def getMeshTopology(self, SearchDirection: BaseContext.SearchDirection = ...) -> BaseMeshTopology:
        """
        Mesh Topology (unified interface for both static and dynamic topologies)
        """
    def getMeshTopologyLink(self, SearchDirection: BaseContext.SearchDirection = ...) -> BaseMeshTopology:
        """
        Mesh Topology (unified interface for both static and dynamic topologies)
        """
    def getRootContext(self) -> BaseContext:
        """
        Get the root context of the graph
        """
    def getState(self) -> ...:
        """
        Mechanical Degrees-of-Freedom
        """
    def getTime(self) -> float:
        """
        Simulation time
        """
    def getTopology(self) -> Topology:
        """
        Topology
        """
    def isActive(self) -> bool:
        """
        The Context is active
        """
    def isSleeping(self) -> bool:
        """
        Sleeping state of the context
        """
    def setActive(self, arg0: bool) -> None:
        """
        State of the context
        """
    def setAnimate(self, arg0: bool) -> None:
        """
        Animation flag
        """
    def setChangeSleepingState(self, arg0: bool) -> None:
        """
        Sleeping state change of the context
        """
    def setDt(self, arg0: float) -> None:
        """
        Simulation timestep
        """
    def setSleeping(self, arg0: bool) -> None:
        """
        Sleeping state of the context
        """
class BaseMass(Base):
    pass
class BaseMechanicalState(Base):
    pass
class BaseMeshTopology(Topology):
    """
    API providing all topology-related functions
    """
    def getEdge(self, index: int) -> typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(2)]:
        """
        Returns the vertices of Edge at index.
        """
    def getEdgesAroundVertex(self, index: int) -> Sofa.Helper.Vectoruint:
        """
        Returns the set of edges adjacent to a given vertex.
        """
    def getEdgesInHexahedron(self, index: int) -> typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(12)]:
        """
        Returns the set of edges adjacent to a given hexahedron.
        """
    def getEdgesInQuad(self, index: int) -> typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(4)]:
        """
        Returns the set of edges adjacent to a given quad.
        """
    def getEdgesInTetrahedron(self, index: int) -> typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(6)]:
        """
        Returns the set of edges adjacent to a given tetrahedron.
        """
    def getEdgesInTriangle(self, index: int) -> typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(3)]:
        """
        Returns the set of edges adjacent to a given triangle.
        """
    def getHexahedraAroundEdge(self, index: int) -> Sofa.Helper.Vectoruint:
        """
        Returns the set of hexahedra adjacent to a given edge.
        """
    def getHexahedraAroundQuad(self, index: int) -> Sofa.Helper.Vectoruint:
        """
        Returns the set of hexahedra adjacent to a given quad.
        """
    def getHexahedraAroundVertex(self, index: int) -> Sofa.Helper.Vectoruint:
        """
        Returns the set of hexahedra adjacent to a given vertex.
        """
    def getHexahedron(self, index: int) -> typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(8)]:
        """
        Returns the vertices of Hexahedron at index.
        """
    def getLocalEdgesInTetrahedron(self, index: int) -> typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(2)]:
        """
        Returns for each index (between 0 and 5) the two vertex indices that are adjacent to that edge.
        """
    def getNbEdges(self) -> int:
        ...
    def getNbHexahedra(self) -> int:
        ...
    def getNbLines(self) -> int:
        ...
    def getNbPoints(self) -> int:
        ...
    def getNbQuads(self) -> int:
        ...
    def getNbTetrahedra(self) -> int:
        ...
    def getNbTetras(self) -> int:
        ...
    def getNbTriangles(self) -> int:
        ...
    def getQuad(self, index: int) -> typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(4)]:
        """
        Returns the vertices of Quad at index.
        """
    def getQuadsAroundEdge(self, index: int) -> Sofa.Helper.Vectoruint:
        """
        Returns the set of quads adjacent to a given edge.
        """
    def getQuadsAroundVertex(self, index: int) -> Sofa.Helper.Vectoruint:
        """
        Returns the set of quads adjacent to a given vertex.
        """
    def getQuadsInHexahedron(self, index: int) -> typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(6)]:
        """
        Returns the set of quads adjacent to a given hexahedron.
        """
    def getTetrahedraAroundEdge(self, index: int) -> Sofa.Helper.Vectoruint:
        """
        Returns the set of tetrahedra adjacent to a given edge.
        """
    def getTetrahedraAroundTriangle(self, index: int) -> Sofa.Helper.Vectoruint:
        """
        Returns the set of tetrahedra adjacent to a given triangle.
        """
    def getTetrahedraAroundVertex(self, index: int) -> Sofa.Helper.Vectoruint:
        """
        Returns the set of tetrahedra adjacent to a given vertex.
        """
    def getTetrahedron(self, index: int) -> typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(4)]:
        """
        Returns the vertices of Tetrahedron at index.
        """
    def getTriangle(self, index: int) -> typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(3)]:
        """
        Returns the vertices of Triangle at index.
        """
    def getTrianglesAroundEdge(self, index: int) -> Sofa.Helper.Vectoruint:
        """
        Returns the set of triangles adjacent to a given edge.
        """
    def getTrianglesAroundVertex(self, index: int) -> Sofa.Helper.Vectoruint:
        """
        Returns the set of triangles adjacent to a given vertex.
        """
    def getTrianglesInTetrahedron(self, index: int) -> typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(4)]:
        """
        Returns the set of triangles adjacent to a given tetrahedron.
        """
    def getVerticesAroundVertex(self, index: int) -> Sofa.Helper.Vectoruint:
        """
        Returns the set of vertices adjacent to a given vertex (i.e. sharing an edge)
        """
class BaseNode(Base):
    """
    Base class for simulation node
    """
class BasePrefab(Node):
    """
    Base class for prefabs (for more see Sofa.prefab)
    """
class Camera(Object):
    """
    
            API dedicated to the control of the Camera in SOFA
    
            Example:
            .. code-block:: python
    
                import Sofa.Core
                import SofaRuntime
                SofaRuntime.importPlugin("SofaComponentAll")
    
                root = Sofa.Core.Node("root")
                root.addObject("Camera", name="c")
                root.c.position.value # Access the position of the camera
                root.c.orientation.value # Access the orientation of the camera in quaternion
    
            :More complex example of use:
    
            The camera, added to a controller, can allow the user to create its own script to move and orientate the camera.
    
            In the example below, the mouse is used to orientate the camera, and the following commands are used to move it : ctrl+z to move forward,
            ctrl+x to move backward, ctrl+d to translate on the right, ctrl+q to translate on the left.
            The code for this example is available in the folder examples under the name BaseCamera.py of the SofaPython3 GitHub repository.
    
            .. image:: ../../../../../../docs/sphinx/source/images/baseCamera.gif
                :alt: Example of a controller for a BaseCamera
                :align: center
                :height: 250pt
    
            
    """
    def Orthographic(self) -> None:
        ...
    def Perspective(self) -> None:
        ...
    @typing.overload
    def getLookAtFromOrientation(self, arg0: list, arg1: float, arg2: list) -> ...:
        ...
    @typing.overload
    def getLookAtFromOrientation(self, arg0: list, arg1: float, arg2: list) -> ...:
        ...
    def getModelViewMatrix(self) -> list[float]:
        ...
    def getOpenGLModelViewMatrix(self) -> list[float]:
        ...
    def getOpenGLProjectionMatrix(self) -> list[float]:
        ...
    def getOrientationFromLookAt(self, arg0: list, arg1: list) -> ...:
        ...
    def getPositionFromOrientation(self, arg0: list, arg1: float, arg2: list) -> ...:
        ...
    def getProjectionMatrix(self) -> list[float]:
        ...
    def rotate(self, arg0: list) -> None:
        ...
    def rotateCameraAroundPoint(self, arg0: list, arg1: list) -> None:
        ...
    def rotateWorldAroundPoint(self, arg0: list, arg1: list, arg2: list) -> None:
        ...
    def screenToWorldPoint(self, arg0: list) -> ...:
        ...
    def setCameraType(self, arg0: int) -> None:
        ...
    def setDefaultView(self) -> None:
        ...
    def worldToScreenPoint(self, arg0: list) -> ...:
        ...
class ClassEntry:
    """
    Record storing information about a class
    """
    def __repr__(self) -> str:
        ...
    def __str__(self) -> str:
        ...
    @property
    def aliases(self) -> list:
        ...
    @property
    def authors(self) -> str:
        ...
    @property
    def className(self) -> str:
        ...
    @property
    def dataAlias(self) -> dict:
        ...
    @property
    def defaultTemplate(self) -> str:
        ...
    @property
    def description(self) -> str:
        ...
    @property
    def license(self) -> str:
        ...
    @property
    def locations(self) -> set[str]:
        ...
    @property
    def targets(self) -> set[str]:
        ...
    @property
    def templates(self) -> set[str]:
        ...
class ContactListener(Object):
    """
    
            Component dedicated to the monitoring of the collision information between models
    
            Example:
    
            .. code-block:: python
    
                import Sofa.Core
                import SofaRuntime
                SofaRuntime.importPlugin("SofaComponentAll")
    
                root = Sofa.Core.Node("root")
                model1 = root.addObject("TriangleCollisionModel")
                model2 = root.addObject("PointCollisionModel")
                listener = root.addObject("ContactListener", collisionModel1=model1.getLinkPath(), collisionModel2=model2.getLinkPath())
                print(listener.getNumberOfContacts())
                print(listener.getDistances())
            
    """
    def getContactData(self) -> dict:
        ...
    def getContactElements(self) -> list[tuple[int, int, int, int]]:
        ...
    def getContactPoints(self) -> list[tuple[int, ..., ..., int, ..., ...]]:
        ...
    def getDistances(self) -> Sofa.Helper.Vectordouble:
        ...
    def getNumberOfContacts(self) -> int:
        ...
class Context(BaseContext):
    """
    Implementation of BaseContext, storing all shared parameters in Datas
    """
class Controller(Object):
    """
    
            Overridable class for user interaction on SOFA Components
    
            It can catch events to trigger actions, such as onAnimateBeginEvent, onAnimateEndEvent or onPythonScriptEvent.
            A new custom controller class needs to be defined to use a controller in a script,
            and that class needs to reimplement the __init__ method.
    
            :example of use:
    
            In the following example, we redefine the controller class, and reimplement the __init__ method.
            We also implement the onAnimateBeginEvent, that will be activted everytime an animation step ends
            and that will simply print a message in the command line. In the createScene function, we initialize
            the controller and add it to the rootNode.
            If you run this with runSofa, it will simply endlessly print `onAnimateBeginEvent`
            when you click the Animate button.
    
                .. code-block:: python
    
                    import Sofa.Core
    
                    class MyController(Sofa.Core.Controller):
                        def __init__(self, *args, **kwargs):
                             ## These are needed (and the normal way to override from a python class)
                             Sofa.Core.Controller.__init__(self, *args, **kwargs)
                             print(" Python::__init__::"+str(self.name))
    
                        def onEvent(self, event):
                             \"\"\"This function is the fallback one that is called if the XXXX event is
                                received but there is not overriden onXXXX() method.
                             \"\"\"
                             print("generic event handler catched ", event)
    
                        def onAnimateBeginEvent(self, event):
                             print("onAnimateBeginEvent")
    
                    def createScene(rootNode):
                        controller = MyController(name="MyC")
                        rootNode.addObject(controller)
                        return rootNode
             
    """
    def __init__(self, *args, **kwargs) -> None:
        ...
    def init(self) -> None:
        ...
    def reinit(self) -> None:
        ...
class Data:
    """
    
            Public attribute of a Component (C++ class) visible and accessible to the user (read/write)
    
            :Create a data field:
    
            To create a data field, you can use the function addData, as shown in the example below. Note that the help
            parameter allows you  to create a help message for the data field, accessible with the getHelp method.
    
            .. code-block:: python
    
                import Sofa.Core
    
                root = Sofa.Core.Node("root")
                root.addData(name="aField", value=1.0 , help="help message",group="theDataGroup",
                    type="float")
    
            :Access the value of a data field in read-only:
    
            Accessing a data field is easy thanks to the generalized access API. You simply need the name of the data field,
            as shown in the following :
    
            .. code-block:: python
    
                import Sofa.Core
    
                root = Sofa.Core.Node("root")
                root.addData(name="aField", value=1.0 , help="help message",group="theDataGroup",
                    type="float")
                valueOfaField = root.aField.value
                print(valueOfaField) #will print '1.0'
    
            Please note that here valueOfaField is a copy of the real value of aField. You can change its value, but it won't change the value of aField.
    
            SOFA elements are often created with data fields, so you won't always need to create data fields.
            For example, most SOFA elements are created with the data field `name` :
    
            .. code-block:: python
    
                import Sofa.Core
    
                root = Sofa.Core.Node("rootNode")
                print(root.name.value) #will print 'rootNode'
    
            However, this API only allows you to access the value of a data field, but not to change it.
    
            :Change the value of a data field:
    
            To change the value of a data field, there are two possibilities. If the type of the data field is a scalar, you can do the following :
    
            .. code-block:: python
    
                import Sofa.Core
    
                root = Sofa.Core.Node("root")
                root.addData(name="aField", value=1.0 , help="help message",group="theDataGroup",
                    type="float")
                root.aField = 3.0 # will change the value of aField
                print(root.aField.value) # will print '3.0'
    
            Or you can create a temporary pointer that will allow you to change the value of aField, instead of giving it a whole new one,
            which is more cost effective when the type of the data field is something other than a scalar:
    
            .. code-block:: python
    
                import Sofa.Core
    
                root = Sofa.Core.Node("root")
                root.addData(name="aField", value=[0.0, 1.0, 3.0] , help="help message",group="theDataGroup",
                    type="Vec3d")
                with root.aField.writeable() as value:
                        value[0] = 3.0
    
                print(root.aField.value) # will print '[3.0, 1.0, 3.0]'
    
            
    """
    def __getattr__(self, arg0: str) -> typing.Any:
        ...
    def __repr__(self) -> str:
        ...
    def __setattr__(self, arg0: str, arg1: typing.Any) -> None:
        ...
    def __str__(self) -> str:
        ...
    def array(self) -> numpy.ndarray:
        """
                Return a python read-only array of the data.
                :rtype: read-only array
        """
    def getCounter(self) -> int:
        """
                Return the number of changes since creation.
                This can be used to efficiently detect changes.
                :rtype: integer
        """
    def getHelp(self) -> str:
        """
                Get the help message.
                :rtype: string
        """
    def getLinkPath(self) -> str:
        """
                Return the path of the link to the data.
                :rtype: string
        """
    def getName(self) -> str:
        """
                Get the name of the data.
                :rtype: string
        """
    def getOwner(self) -> typing.Any:
        """
                Return the Base component owning this data.
                :rtype: Base
        """
    def getParent(self) -> Data:
        """
                Return the parent data of this data.
                :rtype: BaseData
        """
    def getPathName(self) -> str:
        """
                Return the name of the path of the data.
                :rtype: string
        """
    def getValueString(self) -> str:
        """
                Print the value of the associated variable.
        """
    def getValueTypeString(self) -> str:
        """
                Print the value of the associated variable.
        """
    def getValueVoidPtr(self) -> capsule:
        """
                Get a constant void pointer to the value held in this data.
        """
    def hasChanged(self) -> bool:
        """
                Update the data if it is dirty.
                :return: true if it is updated, false otherwise.
                ;rtype: boolean
        """
    def hasParent(self) -> bool:
        """
                Check whether the data has a parent.
                :return: true if the data has a parent.
                :rtype: boolean
        """
    def isDirty(self) -> bool:
        """
                Return true if the DDGNode needs to be updated.
        """
    def isPersistent(self) -> bool:
        """
                Alias to match BaseData API.
                Checks whether the link requires a path in order to be created.
                :return: true if the link requires a path.
                :rtype: boolean
        """
    def isReadOnly(self) -> bool:
        """
                Return whether this data will be read-only in GUIs.
                :return: True for read-only
        """
    def isRequired(self) -> bool:
        """
                Check whether a data is flagged as required for the creation of an object.
                :return: true if it is required.
        """
    def isSet(self) -> bool:
        """
                Check if the value has been modified
                If this data is linked, the value of this data will be considered as modified
                (even if the parent's value has not been modified)
                :return: True if the data has been modified
        """
    def read(self, arg0: str) -> bool:
        """
                Read the command line, set the value of the data to the given content of the command line.
                :param str: the content of the command line
                :type str: string
        """
    def setName(self, arg0: str) -> None:
        """
                Set a new name for the data.
                :param name: the new name
                :type name: string
        """
    @typing.overload
    def setParent(self, arg0: Data) -> None:
        """
                Set a new parent and a new path for the data.
                :param parent: the new parent of the data
                :param path: the new path of the data
                :type parent: BaseData
                :type path: string
        """
    @typing.overload
    def setParent(self, arg0: str) -> None:
        """
                Set a new parent and a new path for the data.
                :param parent: the new parent of the data
                :param path: the new path of the data
                :type parent: BaseData
                :type path: string
        """
    @typing.overload
    def setParent(self, arg0: ...) -> None:
        """
                Set a new parent and a new path for the data.
                :param parent: the new parent of the data
                :param path: the new path of the data
                :type parent: BaseData
                :type path: string
        """
    def setPersistent(self, arg0: bool) -> None:
        """
                Alias to match BaseData API.
                Changes the value of a flag,
                that should be set to true if link requires a path string in order to be created.
                :param bool: new value for the flag.
                :type bool: boolean
        """
    def setReadOnly(self, arg0: bool) -> None:
        """
                Set whether this data is read-only. (True for read-only)
                :param bool: value of the read-only property
                :type bool: boolean
        """
    def toList(self) -> list:
        """
                Return a list containing the value of the vector of data.
        """
    def typeName(self) -> str:
        """
                Return the name of the type of the data.
                :rtype: string
        """
    def unset(self) -> None:
        """
                Reset the isSet flag to false, to indicate that the current value is the default for this data.
        """
    def updateIfDirty(self) -> None:
        """
                Utility method to call update if necessary.
                This method should be called before reading or writing the value of this node.
        """
    @typing.overload
    def writeableArray(self, arg0: typing.Any) -> ...:
        """
                Return a writable array of the data given an Object.
                :param f: the object to convert into an array.
                :type f: python object
                :rtype: writeable array
        """
    @typing.overload
    def writeableArray(self) -> ...:
        """
                Return a new empty array.
                :rtype: writeable array
        """
class DataContainer(Data):
    """
    
            Classic python container implemented for SOFA data fields
    
            
    """
    def __add__(self, arg0: typing.Any) -> typing.Any:
        ...
    def __buffer__(self, flags):
        """
        Return a buffer object that exposes the underlying memory of the object.
        """
    def __getitem__(self, arg0: typing.Any) -> typing.Any:
        ...
    def __iadd__(self, arg0: typing.Any) -> DataContainer:
        ...
    def __imul__(self, arg0: typing.Any) -> typing.Any:
        ...
    def __isub__(self, arg0: typing.Any) -> DataContainer:
        ...
    def __len__(self) -> int:
        """
                Return the number of elements in the container's 1st
                dimension. (equivalent to shape(0))
        """
    def __mul__(self, arg0: typing.Any) -> typing.Any:
        ...
    def __release_buffer__(self, buffer):
        """
        Release the buffer object that exposes the underlying memory of the object.
        """
    def __repr__(self: Data) -> str:
        ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: typing.Any) -> None:
        ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: typing.Any) -> typing.Any:
        ...
    @typing.overload
    def __setitem__(self, arg0: tuple, arg1: typing.Any) -> None:
        ...
    def __str__(self: Data) -> str:
        ...
    def __sub__(self, arg0: typing.Any) -> typing.Any:
        ...
    def apply(self, arg0: typing.Callable) -> None:
        ...
    def array(self) -> numpy.ndarray:
        ...
    def toList(self) -> typing.Any:
        ...
    @typing.overload
    def writeable(self, arg0: typing.Any) -> DataContainerContextManager:
        ...
    @typing.overload
    def writeable(self) -> DataContainerContextManager:
        ...
    @property
    def ndim(self) -> int:
        """
                Return the number of dimensions in the container
        """
    @property
    def shape(self) -> tuple:
        """
                Return the shape of the container (a tuple of length ndim,
                with each value being equal to the length of the given dimension)
        """
    @property
    def size(self) -> int:
        """
                Return the total number of elements in the container
                ( equivalent to math.prod(self.shape()) )
        """
class DataContainerContextManager:
    """
    Container managing context data
    """
    def __enter__(self) -> typing.Any:
        ...
    def __exit__(self, arg0: typing.Any, arg1: typing.Any, arg2: typing.Any) -> None:
        ...
class DataDict:
    """
    
            Exposes the data of a sofa object in a way similar to a normal python dictionnary
    
            Example:
                .. code-block:: python
    
                    for k,v in anObject.__data__.items():
                        print("Data name :"+k+" value:" +str(v)))
            
    """
    @typing.overload
    def __getitem__(self, arg0: int) -> typing.Any:
        ...
    @typing.overload
    def __getitem__(self, arg0: str) -> typing.Any:
        ...
    def __iter__(self) -> ...:
        ...
    def __len__(self) -> int:
        ...
    def __setitem__(self, arg0: str, arg1: typing.Any) -> float:
        ...
    def items(self) -> ...:
        """
                Expose the data, both the key and the value of each item.
                Example:
                    .. code-block:: python
        
                        for k,v in anObject.__data__.items():
                            print("Data name :"+k+" value:" +str(v)))
        """
    def keys(self) -> ...:
        """
                Expose the data, but only the key (the name) of each items
        """
    def values(self) -> ...:
        """
                Expose the data, but only the value of each items
        """
class DataDictIterator:
    """
    
    
            Iterator reimplemented to fit dataDict
    
            
    """
    def __iter__(self) -> DataDictIterator:
        ...
    def __next__(self) -> typing.Any:
        ...
class DataEngine(Object):
    """
    
            Class computing a set of Data outputs from a set of Data inputs
    
            It is a trampoline class that enables python implementations
            of the C++ sofa::core::DataEngine class
            
    """
    def __init__(self, *args, **kwargs) -> None:
        ...
    def addInput(self, arg0: Data) -> None:
        """
                Registers a data as an input for the DataEngine.
        
                :param data: The data to register as input.
                :type data: Sofa.Core.Data.
                :returns:  None.
        """
    def addOutput(self, arg0: Data) -> None:
        """
                Registers a data field as being an output for this engine.
                If an Engine's output is accessed (getValue, beginEdit...)
                AND one or more of its input is dirty, the engine's update()
                method will be called
                :param data: the data to register as an output
                :rtype: None
        """
class DataLink(Data):
    """
    Stores the connection between two object of type Data
    """
    def __repr__(self) -> str:
        ...
    def __str__(self) -> str:
        ...
class DataString(Data):
    """
    Data of type string
    """
    __hash__: typing.ClassVar[None] = None
    def __eq__(self, arg0: Data) -> bool:
        ...
    def __getitem__(self, arg0: int) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    def __repr__(self) -> str:
        ...
    def __str__(self) -> str:
        ...
class DataVectorString(Data):
    """
    Data of type vector<string>
    """
    def __getitem__(self, arg0: int) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    def __repr__(self) -> str:
        ...
    def __str__(self) -> str:
        ...
class ForceFieldRigid2d(Object):
    """
    
                             Overridable class to create your own customized force field
                             
    """
    def __init__(self, *args, **kwargs) -> None:
        ...
    def assembleKMatrix(self) -> scipy.sparse.csr_matrix:
        """
        Assemble the stiffness matrix of a force field.
        
        Note that this function is not free. It assembles the stiffness matrix whether or not it has been assembled previously
        to add it into the global system matrix. Besides, the function does not prevent side effects of a second matrix assembly
        in a single time step.
        
        Typical usage example:
        FEM = root.addObject('HexahedronFEMForceField', name="FEM", youngModulus="4000", poissonRatio="0.3", method="large")
        ...
        stiffness_matrix = self.force_field.assembleKMatrix()
        
        Returns:
            A scipy.sparse.csr_matrix object representing the stiffness matrix of the force field
        """
class ForceFieldRigid3d(Object):
    """
    
                             Overridable class to create your own customized force field
                             
    """
    def __init__(self, *args, **kwargs) -> None:
        ...
    def assembleKMatrix(self) -> scipy.sparse.csr_matrix:
        """
        Assemble the stiffness matrix of a force field.
        
        Note that this function is not free. It assembles the stiffness matrix whether or not it has been assembled previously
        to add it into the global system matrix. Besides, the function does not prevent side effects of a second matrix assembly
        in a single time step.
        
        Typical usage example:
        FEM = root.addObject('HexahedronFEMForceField', name="FEM", youngModulus="4000", poissonRatio="0.3", method="large")
        ...
        stiffness_matrix = self.force_field.assembleKMatrix()
        
        Returns:
            A scipy.sparse.csr_matrix object representing the stiffness matrix of the force field
        """
class ForceFieldVec1d(Object):
    """
    
                             Overridable class to create your own customized force field
                             
    """
    def __init__(self, *args, **kwargs) -> None:
        ...
    def assembleKMatrix(self) -> scipy.sparse.csr_matrix:
        """
        Assemble the stiffness matrix of a force field.
        
        Note that this function is not free. It assembles the stiffness matrix whether or not it has been assembled previously
        to add it into the global system matrix. Besides, the function does not prevent side effects of a second matrix assembly
        in a single time step.
        
        Typical usage example:
        FEM = root.addObject('HexahedronFEMForceField', name="FEM", youngModulus="4000", poissonRatio="0.3", method="large")
        ...
        stiffness_matrix = self.force_field.assembleKMatrix()
        
        Returns:
            A scipy.sparse.csr_matrix object representing the stiffness matrix of the force field
        """
class ForceFieldVec2d(Object):
    """
    
                             Overridable class to create your own customized force field
                             
    """
    def __init__(self, *args, **kwargs) -> None:
        ...
    def assembleKMatrix(self) -> scipy.sparse.csr_matrix:
        """
        Assemble the stiffness matrix of a force field.
        
        Note that this function is not free. It assembles the stiffness matrix whether or not it has been assembled previously
        to add it into the global system matrix. Besides, the function does not prevent side effects of a second matrix assembly
        in a single time step.
        
        Typical usage example:
        FEM = root.addObject('HexahedronFEMForceField', name="FEM", youngModulus="4000", poissonRatio="0.3", method="large")
        ...
        stiffness_matrix = self.force_field.assembleKMatrix()
        
        Returns:
            A scipy.sparse.csr_matrix object representing the stiffness matrix of the force field
        """
class ForceFieldVec3d(Object):
    """
    
                             Overridable class to create your own customized force field
                             
    """
    def __init__(self, *args, **kwargs) -> None:
        ...
    def assembleKMatrix(self) -> scipy.sparse.csr_matrix:
        """
        Assemble the stiffness matrix of a force field.
        
        Note that this function is not free. It assembles the stiffness matrix whether or not it has been assembled previously
        to add it into the global system matrix. Besides, the function does not prevent side effects of a second matrix assembly
        in a single time step.
        
        Typical usage example:
        FEM = root.addObject('HexahedronFEMForceField', name="FEM", youngModulus="4000", poissonRatio="0.3", method="large")
        ...
        stiffness_matrix = self.force_field.assembleKMatrix()
        
        Returns:
            A scipy.sparse.csr_matrix object representing the stiffness matrix of the force field
        """
class ForceFieldVec6d(Object):
    """
    
                             Overridable class to create your own customized force field
                             
    """
    def __init__(self, *args, **kwargs) -> None:
        ...
    def assembleKMatrix(self) -> scipy.sparse.csr_matrix:
        """
        Assemble the stiffness matrix of a force field.
        
        Note that this function is not free. It assembles the stiffness matrix whether or not it has been assembled previously
        to add it into the global system matrix. Besides, the function does not prevent side effects of a second matrix assembly
        in a single time step.
        
        Typical usage example:
        FEM = root.addObject('HexahedronFEMForceField', name="FEM", youngModulus="4000", poissonRatio="0.3", method="large")
        ...
        stiffness_matrix = self.force_field.assembleKMatrix()
        
        Returns:
            A scipy.sparse.csr_matrix object representing the stiffness matrix of the force field
        """
class Link:
    """
    
            Connection created between Data instances of two different Components
    
            A Link allows you to access a sofa component from another one anywhere in the simulation graph.
            In your scene creation file, it usually appear as : input=@../component.
    
            Example:
            .. code-block:: python
    
                import Sofa.Core
                import SofaRuntime
                SofaRuntime.importPlugin("SofaComponentAll")
    
                root = Sofa.Core.Node("root")
                root.addObject("MechanicalObject", name="t")
                link = root.findLink("mechanicalState") # access the link
                link.getValueString() # will print '@/t'
                link.getHelp() # will print the help message for all mechanical states
            
    """
    def __getattr__(self, arg0: str) -> typing.Any:
        ...
    def __setattr__(self, arg0: str, arg1: typing.Any) -> None:
        ...
    def getHelp(self) -> str:
        """
                Get the help message.
                :rtype: string
        """
    def getLinkedBase(self, index: int = 0) -> typing.Any:
        """
                Get the linked base.
                :param index: index of the linked base.
                :type index: int
        """
    def getLinkedPath(self, index: int = 0) -> str:
        """
                Get the linked path.
                :param index: index of the linked path.
                :type index: int
        """
    def getName(self) -> str:
        """
                Get the name of the link.
                :rtype: string
        """
    def getOwnerBase(self) -> typing.Any:
        """
                Get the base owner of the link.
                :rtype: Base
        """
    def getPathName(self) -> str:
        """
                Get the linked path.
                :param index: index of the linked path.
                :type index: int
        """
    def getSize(self) -> int:
        """
                Get the size of the link.
                :rtype: size_t
        """
    def getValueString(self) -> str:
        """
                Print the value of the associated variable.
        """
    def getValueTypeString(self) -> str:
        """
                Print the value of the associated variable.
        """
    def isMultiLink(self) -> bool:
        """
                Checks whether the link is an array.
                :return: true if link is an array.
                :rtype: boolean
        """
    def isPersistent(self) -> bool:
        """
                Alias to match BaseData API.
                Checks whether the link requires a path in order to be created.
                :return: true if the link requires a path.
                :rtype: boolean
        """
    def isReadOnly(self) -> bool:
        """
                Alias to match BaseData API.
                Checks whether the link requires a path in order to be created.
                :return: true if the link doesn't require a path.
                :rtype: boolean
        """
    def read(self, arg0: str) -> bool:
        """
                Read the command line.
                :param str: the content of the command line
                :type str: string
        """
    def setHelp(self, arg0: str) -> None:
        """
                Set the help message.
                :param message: the new help message
                :type message: string
        """
    def setLinkedBase(self, arg0: Base) -> None:
        """
                Get the linked base.
                :param index: index of the linked base.
                :type index: int
        """
    def setName(self, arg0: str) -> None:
        """
                Set a new name for the link.
                :param name: the name to be given to the link
                :type name: string
        """
    def setPersistent(self, arg0: bool) -> None:
        """
                Alias to match BaseData API.
                Changes the value of a flag,
                that should be set to true if link requires a path string in order to be created.
                :param bool: new value for the flag.
                :type bool: boolean
        """
class LinkPath:
    """
    
            Hold a linkpath to an object or a data
    
            Example:
                node.addObject('MechanicalObject", name='o')
                node.addObject(position=node.o.position.linkpath)
    
                str(node.o.linkpath) # prints LinkPath('@/o.position')
                repr(node.o.linkpath) # prints '@/o.position'
            
    """
    def __repr__(self) -> str:
        ...
    def __str__(self) -> str:
        ...
class MassRigid2d(ForceFieldRigid2d):
    """
    
                             Component defining the mass of an object
                             
    """
    def assembleMMatrix(self) -> scipy.sparse.csr_matrix:
        """
        Assemble the mass matrix of a mass.
        
        Note that this function is not free. It assembles the mass matrix whether or not it has been assembled previously
        to add it into the global system matrix. Besides, the function does not prevent side effects of a second matrix assembly
        in a single time step.
        
        Typical usage example:
        mass = root.addObject('MeshMatrixMass', name="mass", totalMass="320")
        ...
        mass_matrix = mass.assembleMMatrix()
        
        Returns:
            A scipy.sparse.csr_matrix object representing the mass matrix of the mass
        """
class MassRigid3d(ForceFieldRigid3d):
    """
    
                             Component defining the mass of an object
                             
    """
    def assembleMMatrix(self) -> scipy.sparse.csr_matrix:
        """
        Assemble the mass matrix of a mass.
        
        Note that this function is not free. It assembles the mass matrix whether or not it has been assembled previously
        to add it into the global system matrix. Besides, the function does not prevent side effects of a second matrix assembly
        in a single time step.
        
        Typical usage example:
        mass = root.addObject('MeshMatrixMass', name="mass", totalMass="320")
        ...
        mass_matrix = mass.assembleMMatrix()
        
        Returns:
            A scipy.sparse.csr_matrix object representing the mass matrix of the mass
        """
class MassVec1d(ForceFieldVec1d):
    """
    
                             Component defining the mass of an object
                             
    """
    def assembleMMatrix(self) -> scipy.sparse.csr_matrix:
        """
        Assemble the mass matrix of a mass.
        
        Note that this function is not free. It assembles the mass matrix whether or not it has been assembled previously
        to add it into the global system matrix. Besides, the function does not prevent side effects of a second matrix assembly
        in a single time step.
        
        Typical usage example:
        mass = root.addObject('MeshMatrixMass', name="mass", totalMass="320")
        ...
        mass_matrix = mass.assembleMMatrix()
        
        Returns:
            A scipy.sparse.csr_matrix object representing the mass matrix of the mass
        """
class MassVec2d(ForceFieldVec2d):
    """
    
                             Component defining the mass of an object
                             
    """
    def assembleMMatrix(self) -> scipy.sparse.csr_matrix:
        """
        Assemble the mass matrix of a mass.
        
        Note that this function is not free. It assembles the mass matrix whether or not it has been assembled previously
        to add it into the global system matrix. Besides, the function does not prevent side effects of a second matrix assembly
        in a single time step.
        
        Typical usage example:
        mass = root.addObject('MeshMatrixMass', name="mass", totalMass="320")
        ...
        mass_matrix = mass.assembleMMatrix()
        
        Returns:
            A scipy.sparse.csr_matrix object representing the mass matrix of the mass
        """
class MassVec3d(ForceFieldVec3d):
    """
    
                             Component defining the mass of an object
                             
    """
    def assembleMMatrix(self) -> scipy.sparse.csr_matrix:
        """
        Assemble the mass matrix of a mass.
        
        Note that this function is not free. It assembles the mass matrix whether or not it has been assembled previously
        to add it into the global system matrix. Besides, the function does not prevent side effects of a second matrix assembly
        in a single time step.
        
        Typical usage example:
        mass = root.addObject('MeshMatrixMass', name="mass", totalMass="320")
        ...
        mass_matrix = mass.assembleMMatrix()
        
        Returns:
            A scipy.sparse.csr_matrix object representing the mass matrix of the mass
        """
class MassVec6d(ForceFieldVec6d):
    """
    
                             Component defining the mass of an object
                             
    """
    def assembleMMatrix(self) -> scipy.sparse.csr_matrix:
        """
        Assemble the mass matrix of a mass.
        
        Note that this function is not free. It assembles the mass matrix whether or not it has been assembled previously
        to add it into the global system matrix. Besides, the function does not prevent side effects of a second matrix assembly
        in a single time step.
        
        Typical usage example:
        mass = root.addObject('MeshMatrixMass', name="mass", totalMass="320")
        ...
        mass_matrix = mass.assembleMMatrix()
        
        Returns:
            A scipy.sparse.csr_matrix object representing the mass matrix of the mass
        """
class Node(BaseNode, Context):
    """
    
            A Node stores other nodes and components.
    
            A simulation in SOFA is described as a scene with an intrinsic generalized hierarchy.
            A scene is composed of nodes organized as a tree or as a Directed Acyclic Graph (DAG).
            The different simulated objects are described in separate nodes, and different representations
            of a same object can be done in different sub-nodes.
    
            Example:
              .. code-block:: python
    
                    import Sofa.Core
    
                    # Create a new node
                    n = Sofa.Core.Node("MyNode")
    
                    # Create a new node
                    n = Sofa.Core.Node("MyNode"")
                    # Add a child node name 'Node2'
                    n.addChild("Node2")
    
                    # Add a mechanical component to MyNode
                    n.addObject("MechanicalObject", name="dofs")
    
                    Sofa.Simulation.init(root)
                    Sofa.Simulation.print(root)
    
            The child nodes, components and parents can be accessed using generator attributes.
    
            Example:
              .. code-block:: python
    
                 # ...
                 n = Sofa.Core.Node("MyNode")
                 for child in n.children:
                     print(child.name)
    
                 for parent in n.parents:
                     print(parent.name)
    
    
            Accessing children or object from the current node is easy thanks to the generalized access
            API.
    
            Example:
              .. code-block:: python
    
                 # ...
                 n = Sofa.Core.Node("MyNode")
                 c1 = n.addChild("child1")
                 c2 = n.addChild("child2")
                 c2.addObject("MechanicalObject", name="dofs")
    
                 # retrieve the node child1/child2 from the 'n' node.
                 n.child1.child2
    
                 # retrieve the child1/child2/dofs.position position data field from 'n'
                 n.child1.child2.dofs.position
    
                 # fast access.
                 n["child1.child2.dofs.position"]
            
    """
    def __getattr__(self, arg0: str) -> typing.Any:
        ...
    def __getitem__(self, arg0: str) -> typing.Any:
        ...
    @typing.overload
    def __init__(self) -> None:
        """
                Initialize the components of this node and all the nodes which depend on it.
                :rtype: Sofa.Simulation.Node
        """
    @typing.overload
    def __init__(self, name: str) -> None:
        """
                Initialize the components of this node and all the nodes which depend on it.
        
                :param name: Name of the node to be created
                :type name: string
                :rtype: Sofa.Simulation.Node
        """
    def add(self, arg0: typing.Any, **kwargs) -> typing.Any:
        """
                Add an prefab,
        
                Example:
                    .. code-block:: python
        
                        def Cube(parentNodes, name="Cube"):
                            cube = parentNode.addChild(name)
                            cube.addObject("MechanicalObject")
                            return cube
        
                        node.add(Cube, name="MyCube"")
        """
    @typing.overload
    def addChild(self, arg0: str, **kwargs) -> typing.Any:
        """
                Add a new node as a child
        
                :param name: name of the child node to be added
                :type name: str
        
                :param kwargs: Extra parameters passed to the created Sofa.Node
                :type kwargs: dict
        
                :rtype: the created :class: Sofa.Simulation.Node
        """
    @typing.overload
    def addChild(self, arg0: Node) -> Node:
        """
                Add an existing node as child
        
                :param node: the node to be added
                :type node: :class: Sofa.Simulation.Node
        
                :rtype: the added :class: Sofa.Simulation.Node
        """
    @typing.overload
    def addObject(self, arg0: str, **kwargs) -> typing.Any:
        """
                Add an object.
        
                :param component_type: the Sofa component's type name to add
                :type component_type: str
        
                :param kwargs: additional keyword arguments
                :type kwargs: dict
        
                :rtype: the created :class: Sofa.Core.Object
        """
    @typing.overload
    def addObject(self, arg0: Object) -> typing.Any:
        """
                Add an existing sofa object.
        
                :param component: The Sofa component
                :type component: :class: Sofa.Core.Object
        
                :rtype: the added :class: Sofa.Core.Object
        """
    def createChild(self, arg0: str, **kwargs) -> typing.Any:
        """
                Deprecated, see addChild
        """
    def createObject(self, arg0: str, **kwargs) -> typing.Any:
        """
                Deprecated, see addObject
        """
    def detachFromGraph(self) -> None:
        """
                Remove the current node from the graph: depending on the type of Node, it can have one or several parents.
        """
    def getAsACreateObjectParameter(self) -> str:
        """
                Get the link of the current node
                :rtype: string
        """
    def getChild(self, arg0: str) -> typing.Any:
        """
                Get the child of a node.
        
                :param n:
                :param name:
                :type n: Sofa.Simulation.Node
                :type name: string
                :return: the child with 'name', None otherwise
        """
    def getForceField(self, arg0: int) -> typing.Any:
        """
                Get the force field of a node, given an index.
                :param index: index of the force field
                :type index: unsigned int.
        """
    def getLinkPath(self) -> str:
        """
                Get the link of the current node
                :param node:
                :type node: Sofa.Simulation.Node*
        """
    def getMass(self) -> typing.Any:
        """
                Get the mass of the node
        """
    def getMechanicalMapping(self) -> typing.Any:
        """
                Get the mechanical mapping of the node.
        """
    def getMechanicalState(self) -> typing.Any:
        """
                Get the mechanical state of the node.
        """
    def getObject(self, arg0: str, **kwargs) -> typing.Any:
        """
                Get a sofa component hold by a node.
        
                :param name:
                :type n: Sofa.Simulation.Node
                :type name: string
                :return: the component with 'name', None otherwise
        
                .. note::
        
                    The extra arguments allowed in the SofaPython (warning=True/False) binding are not supported SofaPython3.
        
                .. code-block:: python
        
                    # SofaPython3:
                    if node.getObject("MyObject") != None:
                        pass
        
                    if node.hasObject("MyObject"):
                        pass
        
                    if "MyObject" in node.objects:
                        pass
        """
    def getPathName(self) -> str:
        """
                Get the path name of the current node
                :rtype: string
        """
    def getRoot(self) -> typing.Any:
        """
                Get the root node of the current node.
                :rtype: Sofa.Simulation.BaseNode*
        """
    def getRootPath(self) -> str:
        """
                Return the path from this node to the root node
        """
    def hasODESolver(self) -> typing.Any:
        """
                Return true if the node includes an ODE Solver
        """
    def hasObject(self, arg0: str) -> typing.Any:
        """
                Check if there is a component with provided name.
        
                :param n
                :param name
                :type n: Sofa.Simulation.Node
                :type name: string
                :return: True if the node has an object with correspdonding name.
        """
    def init(self) -> None:
        """
                Initialize the components of this node and all the nodes which depend on it.
                (beware this is not the python __init__, this is sofa's init())
        
                :param self: the node to initialize
                :type self: Sofa.Simulation.Node&
                :rtype: Sofa.Simulation.Node
        """
    def isInitialized(self) -> bool:
        """
                Checks if the node has been initialized
                :return: true if it has been initialized
        """
    def moveChild(self, arg0: BaseNode, arg1: BaseNode) -> None:
        """
                Move a node from another node.
                :param child: the node to be moved
                :param prevParent: the previous parent of the node to be moved
                :type child: Sofa.Simulation.Node
                :type prevParent: Sofa.Simulation.Node
        """
    @typing.overload
    def removeChild(self, arg0: Node) -> None:
        """
                Remove a child of a node.
                :param self: the node itself
                :param n: the child to remove
                :type self: Sofa.Simulation.Node
                :type n: Sofa.Simulation.Node
                Example:
                >>> node1.removeChild(node2)
        """
    @typing.overload
    def removeChild(self, arg0: str) -> typing.Any:
        """
                Remove a child of a node.
                :param n: the node itself
                :param name: the name of the child to remove
                :type n: Sofa.Simulation.Node&
                :type name: string
                Example:
                >>> node1.removeChild("nameNode2")
        """
    def removeObject(self, arg0: Object) -> None:
        """
                Remove an object
                :param object: the object to be removed
                :type object: BaseObject
        """
    def sendEvent(self, arg0: typing.Any, arg1: str) -> None:
        """
                Send an event to other nodes,
                by creating a PythonScriptEvent and propagating it to the rest of the tree.
                Only the nodes and objects downstream will receive the message.
                :param pyUserData: the user data that can be sent
                :param eventName: the name of the event
                :type pyUserData: py::object
                :type eventName: string
        """
    @property
    def children(self) -> ...:
        """
                Field interface to acces the children of a node.
                The returned object is a iteratable featuring the following operations:
                len, remove_at, __contains__, get_at
        
                Example:
                >>> n = Sofa.Core.Node("MyNode")
                >>> n.addChild("child1")
                >>> for child in n.children:
                >>>     print(child.name)
                >>>
                >>> if "child1" in n.children:
                >>>     print("Yes")
                >>> print(len(n.children))
        """
    @property
    def objects(self) -> ...:
        """
                Field interface to acces the objects of a node.
                The returned object is a iteratable featuring the following operations:
                len, remove_at, __contains__, get_at
        
                Example:
                >>> n = Sofa.Core.Node("MyNode")
                >>> n.addObject("MechanicalObject", name="object1")
                >>> n.addObject("MechanicalObject", name="object2")
                >>> for object in n.objects:
                >>>     print(object.name)
                >>>
                >>> if "object2" in c.objects:
                >>>     print("Yes")
                >>> print(len(n.objects))
        """
    @property
    def parents(self) -> ...:
        """
                Field interface to acces the parents of a node.
                The returned object is a iteratable featuring the following operations:
                len, remove_at, __contains__, get_at
        
                Example:
                >>> n = Sofa.Core.Node("parent1")
                >>> c = n.addChild("child1")
                >>> for parent in c.parents:
                >>>     print(parent.name)
                >>>
                >>> if "parent1" in c.parents:
                >>>     print("Yes")
                >>> print(len(n.parents))
        """
class NodeIterator:
    """
    Iterator on nodes
    """
    def __contains__(self, arg0: str) -> bool:
        ...
    @typing.overload
    def __getitem__(self, arg0: int) -> typing.Any:
        ...
    @typing.overload
    def __getitem__(self, arg0: str) -> typing.Any:
        ...
    def __iter__(self) -> NodeIterator:
        ...
    def __len__(self) -> typing.Any:
        ...
    def __next__(self) -> typing.Any:
        ...
    def at(self, arg0: int) -> typing.Any:
        ...
    def remove_at(self, arg0: int) -> None:
        ...
class Object(Base):
    """
    
            Base class for components which can be added in a simulation
    
            An object defines a part of the functionnality in the simulation
            (stores state data, specify topology, compute forces, etc).
            Each simulation object is related to a context, which gives access to all available external data.
            It is able to process events, if listening enabled (default is false).
    
            Example of use:
            .. code-block:: python
    
                import Sofa.Core
                import SofaRuntime
                SofaRuntime.importPlugin("SofaComponentAll")
    
                root = Sofa.Core.Node("root")
                root.addObject("MechanicalObject", name="obj") # Add a common Sofa object
                root.obj # Access the object
                root.obj.name # Access the name of the object
                root.obj.position.value # Access the position of the object
    
            
    """
    def __getitem__(self, arg0: str) -> typing.Any:
        """
                gets an item using its path (path is dot-separated, relative to the object
                it's called upon & ONLY DESCENDING (no ../):
        
                This method lifts most ambiguities when accessing a node, object or data
                from a path relative to self.
        
                examples:
                ------------
        
                root["node1.node2.object1.value"]
        
                In the example above, node1 and node2 can be inferred as being nodes without performing any checks.
                object1 can be a node or an object, but cannot be a datafield nor a link
                value can be a node or an object (if object1 is a node), or must be a data (if object1 is an object)
        """
    def addSlave(self, arg0: Object) -> None:
        """
                Add a slave to the master BaseObject.
                :param slave: the slave to be added.
                :type slave: BaseObject
        """
    def bwdInit(self) -> None:
        """
                Initialization method called at graph creation and modification, during bottom-up traversal.
        """
    def cleanup(self) -> None:
        """
                Called just before deleting this object
                Any object in the tree bellow this object that are to be removed will be removed only after this call,
                so any references this object holds should still be valid.
        """
    @typing.overload
    def computeBBox(self) -> None:
        """
                Bounding Box computation method.
                Default to empty method.
        """
    @typing.overload
    def computeBBox(self, arg0: ..., arg1: bool) -> None:
        """
                Bounding Box computation method.
                Default to empty method.
        """
    def getAsACreateObjectParameter(self) -> str:
        """
                Return the full path name of this baseObject with an extra prefix '@'
                :rtype: string
        """
    def getCategories(self) -> typing.Any:
        """
                Return the list of categories the current object belongs to.
                :rtype: list
        """
    def getContext(self) -> typing.Any:
        """
                Return the conext of the baseObject.
                :rtype: BaseContext
        """
    @typing.overload
    def getLinkPath(self) -> str:
        """
                Return the link of the baseObject
                :param self: the baseObject itself
                :type self: baseObject
                :rtype: string
        """
    @typing.overload
    def getLinkPath(self) -> str:
        """
                Return the full path name of this baseObject with an extra prefix '@'
                :rtype: string
        """
    def getMaster(self) -> typing.Any:
        """
                Return the master of the baseObject.
                :rtype: BaseObject
        """
    def getPathName(self) -> str:
        """
                Return the full path name of this baseObject
                :rtype: string
        """
    def getSlaves(self) -> list:
        """
                Return the slaves of the baseObject.
                :rtype: list
        """
    def getTarget(self) -> typing.Any:
        """
                Return the target (plugin) that contains the current baseObject.
                :rtype: string
        """
    def init(self) -> None:
        """
                Initialization method called at graph creation and modification, during top-down traversal.Initialize data.
        """
    def reinit(self) -> None:
        """
                Update method called when variables used in precomputation are modified.
        """
    def reset(self) -> None:
        """
                Reset to initial state.
                To save the initial state, see storeResetState().
        """
    def setSrc(self, arg0: str, arg1: Object) -> None:
        """
                Set a source Object and parses it to collect dependent Data.
        """
    def storeResetState(self) -> None:
        """
                Save the initial state for later uses in reset()
        """
class ObjectFactory:
    """
    
        Class used to register and dynamically create objects
    
        It uses the Factory design pattern, where each class is registered in a map,
        and dynamically retrieved given the type name.
    
        It also stores metainformation on each classes, such as description,
        authors, license, and available template types.
        
    """
    components: typing.ClassVar[list]  # value = [<DefaultAnimationLoop at 0x600001fb42a0>, <DefaultVisualManagerLoop at 0x600001fb4380>, <RequiredPlugin at 0x600001fb4460>]
    targets: typing.ClassVar[set] = {'Sofa.Simulation.Core'}
    @staticmethod
    def dump_json() -> str:
        """
            Dump the ObjectFactory in a json string
        """
    @staticmethod
    def getComponent(arg0: str) -> ClassEntry:
        """
            Get an entry given a class name (or alias)
        """
    @staticmethod
    def getComponentsFromTarget(arg0: str) -> list[ClassEntry]:
        """
            Return the registered classes from a given target
        """
    @staticmethod
    def shortName(arg0: str) -> str:
        """
            Return the shortname for this classname. Empty string if no creator exists for this classname.
        """
class PointSetTopologyModifier(Base):
    """
    Topology modifications associated to a set of points
    """
    def addPoints(self, arg0: int, arg1: bool) -> None:
        ...
    def removePoints(self, arg0: list[int], arg1: bool) -> None:
        ...
class PrefabLink:
    """
    Link to a prefab
    """
    @typing.overload
    def __init__(self, arg0: ...) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Link) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: str) -> None:
        ...
    def getTargetBase(self) -> typing.Any:
        ...
    def getTargetPath(self) -> str:
        ...
class RawPrefab(BasePrefab):
    """
    
                Prefabs are python templates for a SOFA scene
    
                They allow to simplify the design of a simulation by using pre-structured python script.
                
    """
    def __init__(self, *args, **kwargs) -> None:
        ...
    def addPrefabParameter(self, name: str, help: str, type: str, default: typing.Any = None) -> None:
        ...
    def init(self) -> None:
        ...
    def reinit(self) -> None:
        ...
    def setSourceTracking(self, arg0: str) -> None:
        ...
class Topology(Object):
    """
    Compatibility topology class (against BaseMeshTopology)
    """
